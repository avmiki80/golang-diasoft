// Package handlers provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package handlers

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// CreateEventRequest defines model for CreateEventRequest.
type CreateEventRequest struct {
	// Description Event description
	Description *string `json:"description,omitempty"`

	// EndDate Event end date and time in RFC3339 format
	EndDate time.Time `json:"endDate"`

	// OffsetTime Time offset in minutes for notifications or reminders
	OffsetTime *int64 `json:"offsetTime,omitempty"`

	// StartDate Event start date and time in RFC3339 format
	StartDate time.Time `json:"startDate"`

	// Title Event title
	Title string `json:"title"`

	// UserId ID of the user who owns the event
	UserId openapi_types.UUID `json:"userId"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Error Error message
	Error string `json:"error"`
}

// Event defines model for Event.
type Event struct {
	// Description Event description
	Description *string `json:"description,omitempty"`

	// EndDate Event end date and time
	EndDate *time.Time `json:"endDate,omitempty"`

	// Id Unique event identifier
	Id *openapi_types.UUID `json:"id,omitempty"`

	// OffsetTime Time offset in minutes
	OffsetTime *int64 `json:"offsetTime,omitempty"`

	// StartDate Event start date and time
	StartDate *time.Time `json:"startDate,omitempty"`

	// Title Event title
	Title *string `json:"title,omitempty"`

	// UserId ID of the user who owns the event
	UserId *openapi_types.UUID `json:"userId,omitempty"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	// Data Response data (can be an object, array, or string)
	Data *SuccessResponse_Data `json:"data,omitempty"`

	// Message Success message
	Message *string `json:"message,omitempty"`
}

// SuccessResponseData1 defines model for .
type SuccessResponseData1 = []Event

// SuccessResponseData2 defines model for .
type SuccessResponseData2 = string

// SuccessResponse_Data Response data (can be an object, array, or string)
type SuccessResponse_Data struct {
	union json.RawMessage
}

// UpdateEventRequest defines model for UpdateEventRequest.
type UpdateEventRequest struct {
	// Description Event description
	Description *string `json:"description,omitempty"`

	// EndDate Event end date and time in RFC3339 format
	EndDate time.Time `json:"endDate"`

	// Id Event ID
	Id openapi_types.UUID `json:"id"`

	// OffsetTime Time offset in minutes for notifications or reminders
	OffsetTime *int64 `json:"offsetTime,omitempty"`

	// StartDate Event start date and time in RFC3339 format
	StartDate time.Time `json:"startDate"`

	// Title Event title
	Title string `json:"title"`

	// UserId ID of the user who owns the event
	UserId openapi_types.UUID `json:"userId"`
}

// FindEventsParams defines parameters for FindEvents.
type FindEventsParams struct {
	// UserId Filter events by user ID
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// StartFrom Filter events starting from this date (RFC3339 format)
	StartFrom *time.Time `form:"startFrom,omitempty" json:"startFrom,omitempty"`

	// StartTo Filter events starting until this date (RFC3339 format)
	StartTo *time.Time `form:"startTo,omitempty" json:"startTo,omitempty"`

	// EndFrom Filter events ending from this date (RFC3339 format)
	EndFrom *time.Time `form:"endFrom,omitempty" json:"endFrom,omitempty"`

	// EndTo Filter events ending until this date (RFC3339 format)
	EndTo *time.Time `form:"endTo,omitempty" json:"endTo,omitempty"`
}

// CreateEventJSONRequestBody defines body for CreateEvent for application/json ContentType.
type CreateEventJSONRequestBody = CreateEventRequest

// UpdateEventJSONRequestBody defines body for UpdateEvent for application/json ContentType.
type UpdateEventJSONRequestBody = UpdateEventRequest

// AsEvent returns the union data inside the SuccessResponse_Data as a Event
func (t SuccessResponse_Data) AsEvent() (Event, error) {
	var body Event
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvent overwrites any union data inside the SuccessResponse_Data as the provided Event
func (t *SuccessResponse_Data) FromEvent(v Event) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvent performs a merge with any union data inside the SuccessResponse_Data, using the provided Event
func (t *SuccessResponse_Data) MergeEvent(v Event) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSuccessResponseData1 returns the union data inside the SuccessResponse_Data as a SuccessResponseData1
func (t SuccessResponse_Data) AsSuccessResponseData1() (SuccessResponseData1, error) {
	var body SuccessResponseData1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSuccessResponseData1 overwrites any union data inside the SuccessResponse_Data as the provided SuccessResponseData1
func (t *SuccessResponse_Data) FromSuccessResponseData1(v SuccessResponseData1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSuccessResponseData1 performs a merge with any union data inside the SuccessResponse_Data, using the provided SuccessResponseData1
func (t *SuccessResponse_Data) MergeSuccessResponseData1(v SuccessResponseData1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSuccessResponseData2 returns the union data inside the SuccessResponse_Data as a SuccessResponseData2
func (t SuccessResponse_Data) AsSuccessResponseData2() (SuccessResponseData2, error) {
	var body SuccessResponseData2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSuccessResponseData2 overwrites any union data inside the SuccessResponse_Data as the provided SuccessResponseData2
func (t *SuccessResponse_Data) FromSuccessResponseData2(v SuccessResponseData2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSuccessResponseData2 performs a merge with any union data inside the SuccessResponse_Data, using the provided SuccessResponseData2
func (t *SuccessResponse_Data) MergeSuccessResponseData2(v SuccessResponseData2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SuccessResponse_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SuccessResponse_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Find events
	// (GET /event)
	FindEvents(ctx echo.Context, params FindEventsParams) error
	// Create a new event
	// (POST /event)
	CreateEvent(ctx echo.Context) error
	// Delete an event
	// (DELETE /event/{id})
	DeleteEvent(ctx echo.Context, id openapi_types.UUID) error
	// Get event by ID
	// (GET /event/{id})
	GetEvent(ctx echo.Context, id openapi_types.UUID) error
	// Update an event
	// (PUT /event/{id})
	UpdateEvent(ctx echo.Context, id openapi_types.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// FindEvents converts echo context to params.
func (w *ServerInterfaceWrapper) FindEvents(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindEventsParams
	// ------------- Optional query parameter "userId" -------------

	err = runtime.BindQueryParameter("form", true, false, "userId", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// ------------- Optional query parameter "startFrom" -------------

	err = runtime.BindQueryParameter("form", true, false, "startFrom", ctx.QueryParams(), &params.StartFrom)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startFrom: %s", err))
	}

	// ------------- Optional query parameter "startTo" -------------

	err = runtime.BindQueryParameter("form", true, false, "startTo", ctx.QueryParams(), &params.StartTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startTo: %s", err))
	}

	// ------------- Optional query parameter "endFrom" -------------

	err = runtime.BindQueryParameter("form", true, false, "endFrom", ctx.QueryParams(), &params.EndFrom)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endFrom: %s", err))
	}

	// ------------- Optional query parameter "endTo" -------------

	err = runtime.BindQueryParameter("form", true, false, "endTo", ctx.QueryParams(), &params.EndTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endTo: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FindEvents(ctx, params)
	return err
}

// CreateEvent converts echo context to params.
func (w *ServerInterfaceWrapper) CreateEvent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateEvent(ctx)
	return err
}

// DeleteEvent converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEvent(ctx, id)
	return err
}

// GetEvent converts echo context to params.
func (w *ServerInterfaceWrapper) GetEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEvent(ctx, id)
	return err
}

// UpdateEvent converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateEvent(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/event", wrapper.FindEvents)
	router.POST(baseURL+"/event", wrapper.CreateEvent)
	router.DELETE(baseURL+"/event/:id", wrapper.DeleteEvent)
	router.GET(baseURL+"/event/:id", wrapper.GetEvent)
	router.PUT(baseURL+"/event/:id", wrapper.UpdateEvent)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
